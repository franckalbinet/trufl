# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_callbacks.ipynb.

# %% auto 0
__all__ = ['Variable', 'Callback', 'State', 'MaxCB', 'MinCB', 'StdCB', 'CountCB', 'MoranICB']

# %% ../nbs/04_callbacks.ipynb 2
from dataclasses import dataclass

# %% ../nbs/04_callbacks.ipynb 3
from pysal.lib import weights
from pysal.explore import esda
import itertools
import fastcore.all as fc
from fastcore.basics import patch
import numpy as np
from scipy.spatial import KDTree
import geopandas as gpd
from typing import List
from collections.abc import Callable

import warnings
warnings.filterwarnings("ignore", category=UserWarning, message="The weights matrix is not fully connected")

# %% ../nbs/04_callbacks.ipynb 5
@dataclass
class Variable:
    "State variable"
    name: str
    value: float

# %% ../nbs/04_callbacks.ipynb 6
class Callback(): pass

# %% ../nbs/04_callbacks.ipynb 8
class State:
    def __init__(self, 
                 measurements:gpd.GeoDataFrame, # Measurements data with `loc_id`, `geometry` and `value` columns. 
                 cbs:List[Callable] # List of Callback functions returning `Variable`s.
                ): 
        "Collect various variables/metrics per grid cell/administrative unit."
        fc.store_attr()

# %% ../nbs/04_callbacks.ipynb 9
@patch
def get(self:State, 
        loc_id:str, # Unique id of the Point feature
        as_numpy=False # Whether or not to return a list of `Variable` or a tuple of numpy arrays.
       ):
    "Get the state variables as defined by `cbs` for a given location (`loc_id`)."
    variables = self.run_cbs(loc_id)
    if as_numpy:
        return (np.array([v.name for v in variables]), 
                np.array([v.value for v in variables]))
    else:
        return variables

# %% ../nbs/04_callbacks.ipynb 10
@patch
def expand_to_k_nearest(self:State, 
                        subset_measurements:gpd.GeoDataFrame, # Measurements for which Variables are computed.
                        k:int=5, # Number of nearest neighbours (possibly belonging to adjacent cells/admin. units to consider.
                       ):
    "Expand measurements of concern possibly to nearest neighbors of surrounding grid cells."
    tree = KDTree(self.measurements.geometry.apply(lambda p: (p.x, p.y)).tolist());
    _, indices = tree.query(subset_measurements.geometry.apply(lambda p: (p.x, p.y)).tolist(), k=k)
    return self.measurements.iloc[indices.flatten()].reset_index(drop=True)

# %% ../nbs/04_callbacks.ipynb 11
@patch
def _flatten(self:State, variables):
    "Flatten list of variables potentially containing both scalar and tuples."
    return list(itertools.chain(*(v if isinstance(v, tuple) else (v,) 
                                  for v in variables)))

# %% ../nbs/04_callbacks.ipynb 12
@patch
def run_cbs(self:State, loc_id):
    "Run Callbacks sequentially and flatten the results if required."
    variables = []
    for cb in self.cbs:
        variables.append(cb(loc_id, self))
    return self._flatten(variables)

# %% ../nbs/04_callbacks.ipynb 14
class MaxCB(Callback):
    "Compute Maximum value of measurements at given location."
    def __call__(self, loc_id, state): 
        return Variable(
            'Max', 
            np.max(state.measurements[state.measurements.loc_id == loc_id]['value'].values))

# %% ../nbs/04_callbacks.ipynb 15
class MinCB(Callback):
    "Compute Minimum value of measurements at given location."
    def __call__(self, loc_id, state): 
        return Variable(
            'Min', 
            np.min(state.measurements[state.measurements.loc_id == loc_id]['value'].values))

# %% ../nbs/04_callbacks.ipynb 16
class StdCB(Callback):
    "Compute Standard deviation of measurements at given location."
    def __call__(self, loc_id, state): 
        return Variable(
            'Standard Deviation', 
            np.std(state.measurements[state.measurements.loc_id == loc_id]['value'].values))

# %% ../nbs/04_callbacks.ipynb 17
class CountCB(Callback):
    "Compute the number of measurements at given location."
    def __call__(self, loc_id, state): 
        return Variable(
            'Count', 
            len(state.measurements[state.measurements.loc_id == loc_id]['value'].values))

# %% ../nbs/04_callbacks.ipynb 18
class MoranICB(Callback):
    "Compute Moran.I of measurements at given location."
    def __init__(self, k=5): fc.store_attr()

    def _weights(self, measurements):
        w = weights.KNN.from_dataframe(measurements, k=self.k)
        w.transform = "R" # Row-standardization
        return w
        
    def __call__(self, loc_id, state): 
        subset = state.measurements[state.measurements.loc_id == loc_id];
        expanded_measurements = state.expand_to_k_nearest(subset, k=self.k)
        moran = esda.moran.Moran(expanded_measurements['value'], self._weights(expanded_measurements))
        return Variable('Moran.I', moran.I), Variable('Moran_p_sim', moran.p_sim)
